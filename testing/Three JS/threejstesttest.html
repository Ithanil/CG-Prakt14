<html>
	<head>
		<title>My first Three.js app</title> 
		<style>canvas { width: 100%; height: 100% }</style> 
	</head> 
	<body> 
		<script src="three.js"></script> 
		<script src="OrbitControls.js"></script>
		<script> 
		
			
	var renderer, camera, controls, moreLight, directionalLight;
	
	// custom global variables
	var back, lane, approach, pinVertices,
		pin1, pin2, pin3, pin4, pin5, pin6, pin7, pin8, pin9, pin10;

	var L = ([
				[0.0257937, 0., 0],
				[0.0359156, 0.01905, 0],
				[0.0496062, 0.05715, 0],
				[0.057277, 0.085725, 0],
				[0.0605282, 0.1143, 0],
				[0.0579501, 0.149225, 0],
				[0.0470281, 0.18415, 0],
				[0.0313944, 0.219075, 0],
				[0.0249555, 0.238125, 0],
				[0.0228219, 0.254, 0],
				[0.023749, 0.276225, 0],
				[0.0265938, 0.29845, 0],
				[0.0305562, 0.320675, 0],
				[0.0323469, 0.3429, 0],
				[0.0323342, 0.348666, 0],
				[0.0298704, 0.361036, 0],
				[0.02286, 0.371526, 0],
				[0.0123698, 0.378536, 0],
				[0.00127, 0.380975, 0]
			]);
	
	
	
	init();
	animate();
		
	function init(){
		document.addEventListener("keydown", keyDown, false);
		scene = new THREE.Scene(); 
		// PerspectiveCamera(fovy, aspect, near, far)
		var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
		var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
		camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
		scene.add(camera);
		controls = new THREE.OrbitControls( camera );
		controls.addEventListener( 'change', render );
		
		
		renderer = new THREE.WebGLRenderer(); 
		renderer.setSize( window.innerWidth, window.innerHeight ); 
		renderer.setClearColorHex( 0xffffff, 1 );	// Canvas Background Color
		document.body.appendChild( renderer.domElement );
		
		// Bahn
		var lane_geometry = new THREE.CubeGeometry(1.05,0.1,18.29); 
		var lane_material = new THREE.MeshBasicMaterial( { color: 0x996633 } ); 
		lane = new THREE.Mesh( lane_geometry, lane_material ); 
		lane.translateY(-0.05);
		scene.add( lane ); 
		
		// Approach
		var appr_geometry = new THREE.CubeGeometry(1.05,0.1,5.0); 
		var appr_material = new THREE.MeshBasicMaterial( { color: 0x5C3D1F } ); 
		approach = new THREE.Mesh( appr_geometry, appr_material ); 
		approach.translateZ(18.29/2.0+2.5);
		approach.translateY(-0.05);
		scene.add( approach ); 
		
	/*// Das schwarze Ding hinten
		var back_geometry = new THREE.CubeGeometry(1.05,1.0,0.1);
		var back_material = new THREE.MeshBasicMaterial ( {color: 0x000000} );
		back = new THREE.Mesh( back_geometry, back_material );
		back.translateZ(-18.29/2.0);
		back.translateY(0.5);
		scene.add( back );*/
		
		// Das Teil, wo die Pins stehen
		var pinline_geometry = new THREE.CubeGeometry(1.05,0.1,4.0);
		var pinline_material = new THREE.MeshPhongMaterial ( {color: 0x5C3D1F} );
		var pinline = new THREE.Mesh( pinline_geometry, pinline_material );
		pinline.translateY(-0.05);
		pinline.translateZ(-22.29/2.0);
		pinline.receiveShadow = true;
		scene.add( pinline );
			
		// Position oder Kamera
		camera.position.set( 4, 4, 21 );
		camera.lookAt( scene.position );
		
		//PinVertices erzeugen
		pinVertices = generatePin(10,L);
		
		//Shattenwurf
		moreLight = new THREE.DirectionalLight(0xffffff, 0.5);
		moreLight.position.set(0,2,0);
		scene.add(moreLight);
			
		// Ambient Directional light Test
		directionalLight = new THREE.DirectionalLight(0xffffff);
		//directionalLight.position.set(1,1.5,1).normalize();
		directionalLight.target.position.set(0,0,-18.29/2);
		directionalLight.shadowCameraNear = 2;
		directionalLight.shadowCameraFar = 15;
		directionalLight.shadowCameraLeft = -0.5;
		directionalLight.shadowCameraRight = 0.5;
		directionalLight.shadowCameraTop = 0.5;
		directionalLight.shadowCameraBottom = -0.5;
		directionalLight.shadowCameraVisible = true;
		directionalLight.castShadow = true;
		scene.add(directionalLight);
		
	}
	
	function animate() {
		requestAnimationFrame( animate );
		render();
		controls.update();
	}
	
	// Renderer
	function render() { 
		renderer.shadowMapEnabled = true;

		renderer.shadowMapBias = 0.0039;
		renderer.shadowMapDarkness = 0.5;
		renderer.shadowMapWidth = 1024;
		renderer.shadowMapHeight = 1024; 
		renderer.render(scene, camera); 
	} 

		
	function keyDown(event) {

		switch(event.keyCode) {

      case 65: ///Key A
		 putPins();
         break;
      case 68: ///Key D
         ;
         break;
      case 87: ///Key W
         ;
         break;
      case 83: ///Key S
         ;
         break;
      default:
         break;
		}
		animate();
	}		
				
			function generatePinSegment(a, b, slices)
			{
				var pinVertices = new Array();

				var dphi = 2*Math.PI/slices;
				var circa = [0,a[1],0]; // point on circ from a
				var circb = [0,b[1],0];
				var nv  = [0, 0, 0]; // normal vector
				var v   = [0, 0 ,0]; // velocity
				var r1 =  Math.sqrt(a[0]*a[0]+a[2]*a[2]); 
				var r2 =  Math.sqrt(b[0]*b[0]+b[2]*b[2]);

				for (var phi,i=0; i <= slices;i++){
					phi = i * dphi;
					circa[0] = r1 * Math.cos(phi);
					circa[2] = r1 * Math.sin(phi);
					circb[0] = r2 * Math.cos(phi);
					circb[2] = r2 * Math.sin(phi);

					pinVertices = pinVertices.concat(circa);
					pinVertices = pinVertices.concat(circb);
				}
				
				return pinVertices;
			}
			
			function generatePin(slices,L) 
			{
				var pinVertices = new Array();
				for (var i = 0; i < L.length-1; i++)
				{
					var a = L[i];
					var b = L[i+1];
					pinVertices = pinVertices.concat(generatePinSegment(a, b, slices));
				}
				return pinVertices;
			}
	
		function putPins(){
			
		 scene.remove(pin1);
		 scene.remove(pin2);
		 scene.remove(pin3);
		 scene.remove(pin4);
		 scene.remove(pin5);
		 scene.remove(pin6);
		 scene.remove(pin7);
		 scene.remove(pin8);
		 scene.remove(pin9);
		 scene.remove(pin10);
		 
			// Die Pins, hier Geometrie
			var pin_geometry = new THREE.Geometry();
			var count = 0;
			for (var i = 0; i < pinVertices.length; i = i + 3) {
					pin_geometry.vertices.push(new THREE.Vector3(pinVertices[i],pinVertices[i+1],pinVertices[i+2]));
					count++;
			}
			
			for (var i = 0; i < count-3; i = i +2) 
			{
				var a = i;
				var b = i+1;
				var c = i+2;
				var d = i+3;
				pin_geometry.faces.push(new THREE.Face3(a,b,c));
				pin_geometry.faces.push(new THREE.Face3(b,d,c));
			}
			pin_geometry.computeFaceNormals();
			var pin_material = new THREE.MeshPhongMaterial({color: 'blue' });
	
			// Die 10 Pins
			pin1 = new THREE.Mesh(pin_geometry, pin_material); 
			pin1.translateX(0);
			pin1.translateZ(-18.29/2);
			pin1.receiveShadow = true;
			pin1.castShadow = true;
			scene.add(pin1);
			
			pin2 = new THREE.Mesh(pin_geometry, pin_material);
			pin2.translateZ(-18.29/2-0.264);
			pin2.translateX(0.3048/2);
			pin2.castShadow = true;
			pin2.receiveShadow = true;
			scene.add(pin2);
			
			pin3 = new THREE.Mesh(pin_geometry, pin_material);
			pin3.translateZ(-18.29/2-0.264);
			pin3.translateX(-0.3048/2);
			pin3.castShadow = true;
			pin3.receiveShadow = true;
			scene.add(pin3);
			
			pin4 = new THREE.Mesh(pin_geometry, pin_material);
			pin4.translateZ(-18.29/2-0.264*2);
			pin4.translateX(-0.3048);
			pin4.castShadow = true;
			pin4.receiveShadow = true;
			scene.add(pin4);
			
			pin5 = new THREE.Mesh(pin_geometry, pin_material);
			pin5.translateZ(-18.29/2-0.264*2);
			pin5.castShadow = true;
			pin5.receiveShadow = true;
			scene.add(pin5);
			
			pin6 = new THREE.Mesh(pin_geometry, pin_material);
			pin6.translateZ(-18.29/2-0.264*2);
			pin6.translateX(0.3048);
			pin6.castShadow = true;
			pin6.receiveShadow = true;
			scene.add(pin6);
			
			pin7 = new THREE.Mesh(pin_geometry, pin_material);
			pin7.translateZ(-18.29/2-0.264*3);
			pin7.translateX(0.3048*3/2);
			pin7.castShadow = true;
			pin7.receiveShadow = true;
			scene.add(pin7);
			
			pin8 = new THREE.Mesh(pin_geometry, pin_material);
			pin8.translateZ(-18.29/2-0.264*3);
			pin8.translateX(0.3048/2);
			pin8.castShadow = true;
			pin8.receiveShadow = true;
			scene.add(pin8);
			
			pin9 = new THREE.Mesh(pin_geometry, pin_material);
			pin9.translateZ(-18.29/2-0.264*3);
			pin9.translateX(-0.3048/2);
			pin9.castShadow = true;
			pin9.receiveShadow = true;
			scene.add(pin9);
			
			pin10 = new THREE.Mesh(pin_geometry, pin_material);
			pin10.translateZ(-18.29/2-0.264*3);
			pin10.translateX(-0.3048*3/2);
			pin10.castShadow = true;
			pin10.receiveShadow = true;
			scene.add(pin10);
			
			animate();
	}
	
	</script>		
	</body>
</html>